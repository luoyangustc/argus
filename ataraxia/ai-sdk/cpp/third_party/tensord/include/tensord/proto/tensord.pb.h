// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensord/proto/tensord.proto

#ifndef PROTOBUF_INCLUDED_tensord_2fproto_2ftensord_2eproto
#define PROTOBUF_INCLUDED_tensord_2fproto_2ftensord_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensord_2fproto_2ftensord_2eproto 

namespace protobuf_tensord_2fproto_2ftensord_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensord_2fproto_2ftensord_2eproto
namespace tensord {
namespace proto {
class Instance;
class InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Instance_Count;
class Instance_CountDefaultTypeInternal;
extern Instance_CountDefaultTypeInternal _Instance_Count_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelConfig;
class ModelConfigDefaultTypeInternal;
extern ModelConfigDefaultTypeInternal _ModelConfig_default_instance_;
class Model_File;
class Model_FileDefaultTypeInternal;
extern Model_FileDefaultTypeInternal _Model_File_default_instance_;
class Model_Input;
class Model_InputDefaultTypeInternal;
extern Model_InputDefaultTypeInternal _Model_Input_default_instance_;
class Model_Output;
class Model_OutputDefaultTypeInternal;
extern Model_OutputDefaultTypeInternal _Model_Output_default_instance_;
}  // namespace proto
}  // namespace tensord
namespace google {
namespace protobuf {
template<> ::tensord::proto::Instance* Arena::CreateMaybeMessage<::tensord::proto::Instance>(Arena*);
template<> ::tensord::proto::Instance_Count* Arena::CreateMaybeMessage<::tensord::proto::Instance_Count>(Arena*);
template<> ::tensord::proto::Model* Arena::CreateMaybeMessage<::tensord::proto::Model>(Arena*);
template<> ::tensord::proto::ModelConfig* Arena::CreateMaybeMessage<::tensord::proto::ModelConfig>(Arena*);
template<> ::tensord::proto::Model_File* Arena::CreateMaybeMessage<::tensord::proto::Model_File>(Arena*);
template<> ::tensord::proto::Model_Input* Arena::CreateMaybeMessage<::tensord::proto::Model_Input>(Arena*);
template<> ::tensord::proto::Model_Output* Arena::CreateMaybeMessage<::tensord::proto::Model_Output>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensord {
namespace proto {

enum Instance_Kind {
  Instance_Kind_GPU = 0,
  Instance_Kind_CPU = 1,
  Instance_Kind_Instance_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Instance_Kind_Instance_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Instance_Kind_IsValid(int value);
const Instance_Kind Instance_Kind_Kind_MIN = Instance_Kind_GPU;
const Instance_Kind Instance_Kind_Kind_MAX = Instance_Kind_CPU;
const int Instance_Kind_Kind_ARRAYSIZE = Instance_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Instance_Kind_descriptor();
inline const ::std::string& Instance_Kind_Name(Instance_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Instance_Kind_descriptor(), value);
}
inline bool Instance_Kind_Parse(
    const ::std::string& name, Instance_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Instance_Kind>(
    Instance_Kind_descriptor(), name, value);
}
enum DataType {
  NONE = 0,
  FLOAT64 = 1,
  FLOAT32 = 2,
  FLOAT16 = 3,
  FLOAT8 = 4,
  INT64 = 5,
  INT32 = 6,
  INT16 = 7,
  INT8 = 8,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = NONE;
const DataType DataType_MAX = INT8;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataType_descriptor();
inline const ::std::string& DataType_Name(DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataType_descriptor(), value);
}
inline bool DataType_Parse(
    const ::std::string& name, DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class Model_File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.Model.File) */ {
 public:
  Model_File();
  virtual ~Model_File();

  Model_File(const Model_File& from);

  inline Model_File& operator=(const Model_File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model_File(Model_File&& from) noexcept
    : Model_File() {
    *this = ::std::move(from);
  }

  inline Model_File& operator=(Model_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Model_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model_File* internal_default_instance() {
    return reinterpret_cast<const Model_File*>(
               &_Model_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Model_File* other);
  friend void swap(Model_File& a, Model_File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model_File* New() const final {
    return CreateMaybeMessage<Model_File>(NULL);
  }

  Model_File* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model_File>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model_File& from);
  void MergeFrom(const Model_File& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model_File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes body = 2;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // string alias = 3;
  void clear_alias();
  static const int kAliasFieldNumber = 3;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // @@protoc_insertion_point(class_scope:tensord.proto.Model.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.Model.Input) */ {
 public:
  Model_Input();
  virtual ~Model_Input();

  Model_Input(const Model_Input& from);

  inline Model_Input& operator=(const Model_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model_Input(Model_Input&& from) noexcept
    : Model_Input() {
    *this = ::std::move(from);
  }

  inline Model_Input& operator=(Model_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Model_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model_Input* internal_default_instance() {
    return reinterpret_cast<const Model_Input*>(
               &_Model_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Model_Input* other);
  friend void swap(Model_Input& a, Model_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model_Input* New() const final {
    return CreateMaybeMessage<Model_Input>(NULL);
  }

  Model_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model_Input& from);
  void MergeFrom(const Model_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 shape = 3;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 3;
  ::google::protobuf::int32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int32 value);
  void add_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .tensord.proto.DataType datatype = 2;
  void clear_datatype();
  static const int kDatatypeFieldNumber = 2;
  ::tensord::proto::DataType datatype() const;
  void set_datatype(::tensord::proto::DataType value);

  // @@protoc_insertion_point(class_scope:tensord.proto.Model.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  mutable int _shape_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int datatype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.Model.Output) */ {
 public:
  Model_Output();
  virtual ~Model_Output();

  Model_Output(const Model_Output& from);

  inline Model_Output& operator=(const Model_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model_Output(Model_Output&& from) noexcept
    : Model_Output() {
    *this = ::std::move(from);
  }

  inline Model_Output& operator=(Model_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Model_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model_Output* internal_default_instance() {
    return reinterpret_cast<const Model_Output*>(
               &_Model_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Model_Output* other);
  friend void swap(Model_Output& a, Model_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model_Output* New() const final {
    return CreateMaybeMessage<Model_Output>(NULL);
  }

  Model_Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model_Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model_Output& from);
  void MergeFrom(const Model_Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 shape = 3;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 3;
  ::google::protobuf::int32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int32 value);
  void add_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .tensord.proto.DataType datatype = 2;
  void clear_datatype();
  static const int kDatatypeFieldNumber = 2;
  ::tensord::proto::DataType datatype() const;
  void set_datatype(::tensord::proto::DataType value);

  // @@protoc_insertion_point(class_scope:tensord.proto.Model.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  mutable int _shape_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int datatype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(NULL);
  }

  Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Model_File File;
  typedef Model_Input Input;
  typedef Model_Output Output;

  // accessors -------------------------------------------------------

  // repeated .tensord.proto.Model.File file = 5;
  int file_size() const;
  void clear_file();
  static const int kFileFieldNumber = 5;
  ::tensord::proto::Model_File* mutable_file(int index);
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_File >*
      mutable_file();
  const ::tensord::proto::Model_File& file(int index) const;
  ::tensord::proto::Model_File* add_file();
  const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_File >&
      file() const;

  // repeated .tensord.proto.Model.Input input = 6;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 6;
  ::tensord::proto::Model_Input* mutable_input(int index);
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Input >*
      mutable_input();
  const ::tensord::proto::Model_Input& input(int index) const;
  ::tensord::proto::Model_Input* add_input();
  const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Input >&
      input() const;

  // repeated .tensord.proto.Model.Output output = 7;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 7;
  ::tensord::proto::Model_Output* mutable_output(int index);
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Output >*
      mutable_output();
  const ::tensord::proto::Model_Output& output(int index) const;
  ::tensord::proto::Model_Output* add_output();
  const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Output >&
      output() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string platform = 3;
  void clear_platform();
  static const int kPlatformFieldNumber = 3;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // int32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int32 maxBatchSize = 4;
  void clear_maxbatchsize();
  static const int kMaxBatchSizeFieldNumber = 4;
  ::google::protobuf::int32 maxbatchsize() const;
  void set_maxbatchsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensord.proto.Model)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_File > file_;
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Input > input_;
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Output > output_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 maxbatchsize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Instance_Count : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.Instance.Count) */ {
 public:
  Instance_Count();
  virtual ~Instance_Count();

  Instance_Count(const Instance_Count& from);

  inline Instance_Count& operator=(const Instance_Count& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instance_Count(Instance_Count&& from) noexcept
    : Instance_Count() {
    *this = ::std::move(from);
  }

  inline Instance_Count& operator=(Instance_Count&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance_Count& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance_Count* internal_default_instance() {
    return reinterpret_cast<const Instance_Count*>(
               &_Instance_Count_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Instance_Count* other);
  friend void swap(Instance_Count& a, Instance_Count& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instance_Count* New() const final {
    return CreateMaybeMessage<Instance_Count>(NULL);
  }

  Instance_Count* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instance_Count>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instance_Count& from);
  void MergeFrom(const Instance_Count& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance_Count* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 gpu = 4;
  int gpu_size() const;
  void clear_gpu();
  static const int kGpuFieldNumber = 4;
  ::google::protobuf::int32 gpu(int index) const;
  void set_gpu(int index, ::google::protobuf::int32 value);
  void add_gpu(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      gpu() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_gpu();

  // int32 count = 1;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 batchSize = 2;
  void clear_batchsize();
  static const int kBatchSizeFieldNumber = 2;
  ::google::protobuf::int32 batchsize() const;
  void set_batchsize(::google::protobuf::int32 value);

  // .tensord.proto.Instance.Kind kind = 3;
  void clear_kind();
  static const int kKindFieldNumber = 3;
  ::tensord::proto::Instance_Kind kind() const;
  void set_kind(::tensord::proto::Instance_Kind value);

  // @@protoc_insertion_point(class_scope:tensord.proto.Instance.Count)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > gpu_;
  mutable int _gpu_cached_byte_size_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 batchsize_;
  int kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Instance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.Instance) */ {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(Instance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Instance* other);
  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const final {
    return CreateMaybeMessage<Instance>(NULL);
  }

  Instance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Instance_Count Count;

  typedef Instance_Kind Kind;
  static const Kind GPU =
    Instance_Kind_GPU;
  static const Kind CPU =
    Instance_Kind_CPU;
  static inline bool Kind_IsValid(int value) {
    return Instance_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    Instance_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    Instance_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    Instance_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return Instance_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return Instance_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return Instance_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .tensord.proto.Instance.Count count = 4;
  int count_size() const;
  void clear_count();
  static const int kCountFieldNumber = 4;
  ::tensord::proto::Instance_Count* mutable_count(int index);
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance_Count >*
      mutable_count();
  const ::tensord::proto::Instance_Count& count(int index) const;
  ::tensord::proto::Instance_Count* add_count();
  const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance_Count >&
      count() const;

  // string model = 1;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // int32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // int32 batchSize = 3;
  void clear_batchsize();
  static const int kBatchSizeFieldNumber = 3;
  ::google::protobuf::int32 batchsize() const;
  void set_batchsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensord.proto.Instance)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance_Count > count_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 batchsize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensord.proto.ModelConfig) */ {
 public:
  ModelConfig();
  virtual ~ModelConfig();

  ModelConfig(const ModelConfig& from);

  inline ModelConfig& operator=(const ModelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelConfig(ModelConfig&& from) noexcept
    : ModelConfig() {
    *this = ::std::move(from);
  }

  inline ModelConfig& operator=(ModelConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelConfig* internal_default_instance() {
    return reinterpret_cast<const ModelConfig*>(
               &_ModelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ModelConfig* other);
  friend void swap(ModelConfig& a, ModelConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelConfig* New() const final {
    return CreateMaybeMessage<ModelConfig>(NULL);
  }

  ModelConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelConfig& from);
  void MergeFrom(const ModelConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensord.proto.Model model = 2;
  int model_size() const;
  void clear_model();
  static const int kModelFieldNumber = 2;
  ::tensord::proto::Model* mutable_model(int index);
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model >*
      mutable_model();
  const ::tensord::proto::Model& model(int index) const;
  ::tensord::proto::Model* add_model();
  const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model >&
      model() const;

  // repeated .tensord.proto.Instance instance = 5;
  int instance_size() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 5;
  ::tensord::proto::Instance* mutable_instance(int index);
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance >*
      mutable_instance();
  const ::tensord::proto::Instance& instance(int index) const;
  ::tensord::proto::Instance* add_instance();
  const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance >&
      instance() const;

  // string modelRoot = 1;
  void clear_modelroot();
  static const int kModelRootFieldNumber = 1;
  const ::std::string& modelroot() const;
  void set_modelroot(const ::std::string& value);
  #if LANG_CXX11
  void set_modelroot(::std::string&& value);
  #endif
  void set_modelroot(const char* value);
  void set_modelroot(const char* value, size_t size);
  ::std::string* mutable_modelroot();
  ::std::string* release_modelroot();
  void set_allocated_modelroot(::std::string* modelroot);

  // @@protoc_insertion_point(class_scope:tensord.proto.ModelConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model > model_;
  ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance > instance_;
  ::google::protobuf::internal::ArenaStringPtr modelroot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensord_2fproto_2ftensord_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Model_File

// string name = 1;
inline void Model_File::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model_File::name() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.File.name)
  return name_.GetNoArena();
}
inline void Model_File::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.File.name)
}
#if LANG_CXX11
inline void Model_File::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.File.name)
}
#endif
inline void Model_File::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.File.name)
}
inline void Model_File::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.File.name)
}
inline ::std::string* Model_File::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.File.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model_File::release_name() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.File.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model_File::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.File.name)
}

// bytes body = 2;
inline void Model_File::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model_File::body() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.File.body)
  return body_.GetNoArena();
}
inline void Model_File::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.File.body)
}
#if LANG_CXX11
inline void Model_File::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.File.body)
}
#endif
inline void Model_File::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.File.body)
}
inline void Model_File::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.File.body)
}
inline ::std::string* Model_File::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.File.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model_File::release_body() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.File.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model_File::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.File.body)
}

// string alias = 3;
inline void Model_File::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model_File::alias() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.File.alias)
  return alias_.GetNoArena();
}
inline void Model_File::set_alias(const ::std::string& value) {
  
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.File.alias)
}
#if LANG_CXX11
inline void Model_File::set_alias(::std::string&& value) {
  
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.File.alias)
}
#endif
inline void Model_File::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.File.alias)
}
inline void Model_File::set_alias(const char* value, size_t size) {
  
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.File.alias)
}
inline ::std::string* Model_File::mutable_alias() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.File.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model_File::release_alias() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.File.alias)
  
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model_File::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    
  } else {
    
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.File.alias)
}

// -------------------------------------------------------------------

// Model_Input

// string name = 1;
inline void Model_Input::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model_Input::name() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.Input.name)
  return name_.GetNoArena();
}
inline void Model_Input::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.Input.name)
}
#if LANG_CXX11
inline void Model_Input::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.Input.name)
}
#endif
inline void Model_Input::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.Input.name)
}
inline void Model_Input::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.Input.name)
}
inline ::std::string* Model_Input::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.Input.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model_Input::release_name() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.Input.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model_Input::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.Input.name)
}

// .tensord.proto.DataType datatype = 2;
inline void Model_Input::clear_datatype() {
  datatype_ = 0;
}
inline ::tensord::proto::DataType Model_Input::datatype() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.Input.datatype)
  return static_cast< ::tensord::proto::DataType >(datatype_);
}
inline void Model_Input::set_datatype(::tensord::proto::DataType value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Model.Input.datatype)
}

// repeated int32 shape = 3;
inline int Model_Input::shape_size() const {
  return shape_.size();
}
inline void Model_Input::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 Model_Input::shape(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.Input.shape)
  return shape_.Get(index);
}
inline void Model_Input::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.Input.shape)
}
inline void Model_Input::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:tensord.proto.Model.Input.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Model_Input::shape() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Model.Input.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Model_Input::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Model.Input.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// Model_Output

// string name = 1;
inline void Model_Output::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model_Output::name() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.Output.name)
  return name_.GetNoArena();
}
inline void Model_Output::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.Output.name)
}
#if LANG_CXX11
inline void Model_Output::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.Output.name)
}
#endif
inline void Model_Output::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.Output.name)
}
inline void Model_Output::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.Output.name)
}
inline ::std::string* Model_Output::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.Output.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model_Output::release_name() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.Output.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model_Output::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.Output.name)
}

// .tensord.proto.DataType datatype = 2;
inline void Model_Output::clear_datatype() {
  datatype_ = 0;
}
inline ::tensord::proto::DataType Model_Output::datatype() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.Output.datatype)
  return static_cast< ::tensord::proto::DataType >(datatype_);
}
inline void Model_Output::set_datatype(::tensord::proto::DataType value) {
  
  datatype_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Model.Output.datatype)
}

// repeated int32 shape = 3;
inline int Model_Output::shape_size() const {
  return shape_.size();
}
inline void Model_Output::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 Model_Output::shape(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.Output.shape)
  return shape_.Get(index);
}
inline void Model_Output::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.Output.shape)
}
inline void Model_Output::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:tensord.proto.Model.Output.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Model_Output::shape() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Model.Output.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Model_Output::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Model.Output.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// Model

// string name = 1;
inline void Model::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model::name() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.name)
  return name_.GetNoArena();
}
inline void Model::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.name)
}
#if LANG_CXX11
inline void Model::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.name)
}
#endif
inline void Model::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.name)
}
inline void Model::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.name)
}
inline ::std::string* Model::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model::release_name() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.name)
}

// int32 version = 2;
inline void Model::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Model::version() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.version)
  return version_;
}
inline void Model::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Model.version)
}

// string platform = 3;
inline void Model::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Model::platform() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.platform)
  return platform_.GetNoArena();
}
inline void Model::set_platform(const ::std::string& value) {
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Model.platform)
}
#if LANG_CXX11
inline void Model::set_platform(::std::string&& value) {
  
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Model.platform)
}
#endif
inline void Model::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Model.platform)
}
inline void Model::set_platform(const char* value, size_t size) {
  
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Model.platform)
}
inline ::std::string* Model::mutable_platform() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model::release_platform() {
  // @@protoc_insertion_point(field_release:tensord.proto.Model.platform)
  
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    
  } else {
    
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Model.platform)
}

// int32 maxBatchSize = 4;
inline void Model::clear_maxbatchsize() {
  maxbatchsize_ = 0;
}
inline ::google::protobuf::int32 Model::maxbatchsize() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.maxBatchSize)
  return maxbatchsize_;
}
inline void Model::set_maxbatchsize(::google::protobuf::int32 value) {
  
  maxbatchsize_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Model.maxBatchSize)
}

// repeated .tensord.proto.Model.File file = 5;
inline int Model::file_size() const {
  return file_.size();
}
inline void Model::clear_file() {
  file_.Clear();
}
inline ::tensord::proto::Model_File* Model::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.file)
  return file_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_File >*
Model::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Model.file)
  return &file_;
}
inline const ::tensord::proto::Model_File& Model::file(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.file)
  return file_.Get(index);
}
inline ::tensord::proto::Model_File* Model::add_file() {
  // @@protoc_insertion_point(field_add:tensord.proto.Model.file)
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_File >&
Model::file() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Model.file)
  return file_;
}

// repeated .tensord.proto.Model.Input input = 6;
inline int Model::input_size() const {
  return input_.size();
}
inline void Model::clear_input() {
  input_.Clear();
}
inline ::tensord::proto::Model_Input* Model::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.input)
  return input_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Input >*
Model::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Model.input)
  return &input_;
}
inline const ::tensord::proto::Model_Input& Model::input(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.input)
  return input_.Get(index);
}
inline ::tensord::proto::Model_Input* Model::add_input() {
  // @@protoc_insertion_point(field_add:tensord.proto.Model.input)
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Input >&
Model::input() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Model.input)
  return input_;
}

// repeated .tensord.proto.Model.Output output = 7;
inline int Model::output_size() const {
  return output_.size();
}
inline void Model::clear_output() {
  output_.Clear();
}
inline ::tensord::proto::Model_Output* Model::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:tensord.proto.Model.output)
  return output_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Output >*
Model::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Model.output)
  return &output_;
}
inline const ::tensord::proto::Model_Output& Model::output(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Model.output)
  return output_.Get(index);
}
inline ::tensord::proto::Model_Output* Model::add_output() {
  // @@protoc_insertion_point(field_add:tensord.proto.Model.output)
  return output_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model_Output >&
Model::output() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Model.output)
  return output_;
}

// -------------------------------------------------------------------

// Instance_Count

// int32 count = 1;
inline void Instance_Count::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 Instance_Count::count() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.Count.count)
  return count_;
}
inline void Instance_Count::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.Count.count)
}

// int32 batchSize = 2;
inline void Instance_Count::clear_batchsize() {
  batchsize_ = 0;
}
inline ::google::protobuf::int32 Instance_Count::batchsize() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.Count.batchSize)
  return batchsize_;
}
inline void Instance_Count::set_batchsize(::google::protobuf::int32 value) {
  
  batchsize_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.Count.batchSize)
}

// .tensord.proto.Instance.Kind kind = 3;
inline void Instance_Count::clear_kind() {
  kind_ = 0;
}
inline ::tensord::proto::Instance_Kind Instance_Count::kind() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.Count.kind)
  return static_cast< ::tensord::proto::Instance_Kind >(kind_);
}
inline void Instance_Count::set_kind(::tensord::proto::Instance_Kind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.Count.kind)
}

// repeated int32 gpu = 4;
inline int Instance_Count::gpu_size() const {
  return gpu_.size();
}
inline void Instance_Count::clear_gpu() {
  gpu_.Clear();
}
inline ::google::protobuf::int32 Instance_Count::gpu(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.Count.gpu)
  return gpu_.Get(index);
}
inline void Instance_Count::set_gpu(int index, ::google::protobuf::int32 value) {
  gpu_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.Count.gpu)
}
inline void Instance_Count::add_gpu(::google::protobuf::int32 value) {
  gpu_.Add(value);
  // @@protoc_insertion_point(field_add:tensord.proto.Instance.Count.gpu)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Instance_Count::gpu() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Instance.Count.gpu)
  return gpu_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Instance_Count::mutable_gpu() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Instance.Count.gpu)
  return &gpu_;
}

// -------------------------------------------------------------------

// Instance

// string model = 1;
inline void Instance::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Instance::model() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.model)
  return model_.GetNoArena();
}
inline void Instance::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.model)
}
#if LANG_CXX11
inline void Instance::set_model(::std::string&& value) {
  
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.Instance.model)
}
#endif
inline void Instance::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.Instance.model)
}
inline void Instance::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.Instance.model)
}
inline ::std::string* Instance::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.Instance.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instance::release_model() {
  // @@protoc_insertion_point(field_release:tensord.proto.Instance.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instance::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.Instance.model)
}

// int32 version = 2;
inline void Instance::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Instance::version() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.version)
  return version_;
}
inline void Instance::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.version)
}

// int32 batchSize = 3;
inline void Instance::clear_batchsize() {
  batchsize_ = 0;
}
inline ::google::protobuf::int32 Instance::batchsize() const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.batchSize)
  return batchsize_;
}
inline void Instance::set_batchsize(::google::protobuf::int32 value) {
  
  batchsize_ = value;
  // @@protoc_insertion_point(field_set:tensord.proto.Instance.batchSize)
}

// repeated .tensord.proto.Instance.Count count = 4;
inline int Instance::count_size() const {
  return count_.size();
}
inline void Instance::clear_count() {
  count_.Clear();
}
inline ::tensord::proto::Instance_Count* Instance::mutable_count(int index) {
  // @@protoc_insertion_point(field_mutable:tensord.proto.Instance.count)
  return count_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance_Count >*
Instance::mutable_count() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.Instance.count)
  return &count_;
}
inline const ::tensord::proto::Instance_Count& Instance::count(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.Instance.count)
  return count_.Get(index);
}
inline ::tensord::proto::Instance_Count* Instance::add_count() {
  // @@protoc_insertion_point(field_add:tensord.proto.Instance.count)
  return count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance_Count >&
Instance::count() const {
  // @@protoc_insertion_point(field_list:tensord.proto.Instance.count)
  return count_;
}

// -------------------------------------------------------------------

// ModelConfig

// string modelRoot = 1;
inline void ModelConfig::clear_modelroot() {
  modelroot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ModelConfig::modelroot() const {
  // @@protoc_insertion_point(field_get:tensord.proto.ModelConfig.modelRoot)
  return modelroot_.GetNoArena();
}
inline void ModelConfig::set_modelroot(const ::std::string& value) {
  
  modelroot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensord.proto.ModelConfig.modelRoot)
}
#if LANG_CXX11
inline void ModelConfig::set_modelroot(::std::string&& value) {
  
  modelroot_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensord.proto.ModelConfig.modelRoot)
}
#endif
inline void ModelConfig::set_modelroot(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  modelroot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensord.proto.ModelConfig.modelRoot)
}
inline void ModelConfig::set_modelroot(const char* value, size_t size) {
  
  modelroot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensord.proto.ModelConfig.modelRoot)
}
inline ::std::string* ModelConfig::mutable_modelroot() {
  
  // @@protoc_insertion_point(field_mutable:tensord.proto.ModelConfig.modelRoot)
  return modelroot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelConfig::release_modelroot() {
  // @@protoc_insertion_point(field_release:tensord.proto.ModelConfig.modelRoot)
  
  return modelroot_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelConfig::set_allocated_modelroot(::std::string* modelroot) {
  if (modelroot != NULL) {
    
  } else {
    
  }
  modelroot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelroot);
  // @@protoc_insertion_point(field_set_allocated:tensord.proto.ModelConfig.modelRoot)
}

// repeated .tensord.proto.Model model = 2;
inline int ModelConfig::model_size() const {
  return model_.size();
}
inline void ModelConfig::clear_model() {
  model_.Clear();
}
inline ::tensord::proto::Model* ModelConfig::mutable_model(int index) {
  // @@protoc_insertion_point(field_mutable:tensord.proto.ModelConfig.model)
  return model_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model >*
ModelConfig::mutable_model() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.ModelConfig.model)
  return &model_;
}
inline const ::tensord::proto::Model& ModelConfig::model(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.ModelConfig.model)
  return model_.Get(index);
}
inline ::tensord::proto::Model* ModelConfig::add_model() {
  // @@protoc_insertion_point(field_add:tensord.proto.ModelConfig.model)
  return model_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Model >&
ModelConfig::model() const {
  // @@protoc_insertion_point(field_list:tensord.proto.ModelConfig.model)
  return model_;
}

// repeated .tensord.proto.Instance instance = 5;
inline int ModelConfig::instance_size() const {
  return instance_.size();
}
inline void ModelConfig::clear_instance() {
  instance_.Clear();
}
inline ::tensord::proto::Instance* ModelConfig::mutable_instance(int index) {
  // @@protoc_insertion_point(field_mutable:tensord.proto.ModelConfig.instance)
  return instance_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance >*
ModelConfig::mutable_instance() {
  // @@protoc_insertion_point(field_mutable_list:tensord.proto.ModelConfig.instance)
  return &instance_;
}
inline const ::tensord::proto::Instance& ModelConfig::instance(int index) const {
  // @@protoc_insertion_point(field_get:tensord.proto.ModelConfig.instance)
  return instance_.Get(index);
}
inline ::tensord::proto::Instance* ModelConfig::add_instance() {
  // @@protoc_insertion_point(field_add:tensord.proto.ModelConfig.instance)
  return instance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensord::proto::Instance >&
ModelConfig::instance() const {
  // @@protoc_insertion_point(field_list:tensord.proto.ModelConfig.instance)
  return instance_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tensord

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tensord::proto::Instance_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensord::proto::Instance_Kind>() {
  return ::tensord::proto::Instance_Kind_descriptor();
}
template <> struct is_proto_enum< ::tensord::proto::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensord::proto::DataType>() {
  return ::tensord::proto::DataType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensord_2fproto_2ftensord_2eproto
