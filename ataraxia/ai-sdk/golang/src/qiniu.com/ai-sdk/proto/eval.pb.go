// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eval.proto

/*
	Package eval is a generated protocol buffer package.

	It is generated from these files:
		eval.proto

	It has these top-level messages:
		ForwardMsg
		ForwardMsgs
		InferenceRequest
		InferenceResponse
		MonitorMetric
		NumpyNdarray
		PingMsg
*/
package eval

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ForwardMsg struct {
	Uuid             string            `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Reqid            string            `protobuf:"bytes,6,opt,name=reqid,proto3" json:"reqid,omitempty"`
	Meta             map[string][]byte `protobuf:"bytes,2,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NetworkInputBuf  []byte            `protobuf:"bytes,3,opt,name=network_input_buf,json=networkInputBuf,proto3" json:"network_input_buf,omitempty"`
	NetworkOutputBuf []byte            `protobuf:"bytes,4,opt,name=network_output_buf,json=networkOutputBuf,proto3" json:"network_output_buf,omitempty"`
	Desc             string            `protobuf:"bytes,5,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *ForwardMsg) Reset()                    { *m = ForwardMsg{} }
func (m *ForwardMsg) String() string            { return proto.CompactTextString(m) }
func (*ForwardMsg) ProtoMessage()               {}
func (*ForwardMsg) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{0} }

func (m *ForwardMsg) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ForwardMsg) GetReqid() string {
	if m != nil {
		return m.Reqid
	}
	return ""
}

func (m *ForwardMsg) GetMeta() map[string][]byte {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ForwardMsg) GetNetworkInputBuf() []byte {
	if m != nil {
		return m.NetworkInputBuf
	}
	return nil
}

func (m *ForwardMsg) GetNetworkOutputBuf() []byte {
	if m != nil {
		return m.NetworkOutputBuf
	}
	return nil
}

func (m *ForwardMsg) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type ForwardMsgs struct {
	Msgs []*ForwardMsg `protobuf:"bytes,1,rep,name=msgs" json:"msgs,omitempty"`
}

func (m *ForwardMsgs) Reset()                    { *m = ForwardMsgs{} }
func (m *ForwardMsgs) String() string            { return proto.CompactTextString(m) }
func (*ForwardMsgs) ProtoMessage()               {}
func (*ForwardMsgs) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{1} }

func (m *ForwardMsgs) GetMsgs() []*ForwardMsg {
	if m != nil {
		return m.Msgs
	}
	return nil
}

type InferenceRequest struct {
	Data   *InferenceRequest_RequestData   `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
	Datas  []*InferenceRequest_RequestData `protobuf:"bytes,2,rep,name=datas" json:"datas,omitempty"`
	Params string                          `protobuf:"bytes,3,opt,name=params,proto3" json:"params,omitempty"`
	Reqid  string                          `protobuf:"bytes,4,opt,name=reqid,proto3" json:"reqid,omitempty"`
}

func (m *InferenceRequest) Reset()                    { *m = InferenceRequest{} }
func (m *InferenceRequest) String() string            { return proto.CompactTextString(m) }
func (*InferenceRequest) ProtoMessage()               {}
func (*InferenceRequest) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{2} }

func (m *InferenceRequest) GetData() *InferenceRequest_RequestData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *InferenceRequest) GetDatas() []*InferenceRequest_RequestData {
	if m != nil {
		return m.Datas
	}
	return nil
}

func (m *InferenceRequest) GetParams() string {
	if m != nil {
		return m.Params
	}
	return ""
}

func (m *InferenceRequest) GetReqid() string {
	if m != nil {
		return m.Reqid
	}
	return ""
}

type InferenceRequest_RequestData struct {
	Uri       string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Attribute string `protobuf:"bytes,2,opt,name=attribute,proto3" json:"attribute,omitempty"`
	Body      []byte `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *InferenceRequest_RequestData) Reset()         { *m = InferenceRequest_RequestData{} }
func (m *InferenceRequest_RequestData) String() string { return proto.CompactTextString(m) }
func (*InferenceRequest_RequestData) ProtoMessage()    {}
func (*InferenceRequest_RequestData) Descriptor() ([]byte, []int) {
	return fileDescriptorEval, []int{2, 0}
}

func (m *InferenceRequest_RequestData) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *InferenceRequest_RequestData) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *InferenceRequest_RequestData) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type InferenceResponse struct {
	Code    int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Result  string `protobuf:"bytes,5,opt,name=result,proto3" json:"result,omitempty"`
	Body    []byte `protobuf:"bytes,6,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *InferenceResponse) Reset()                    { *m = InferenceResponse{} }
func (m *InferenceResponse) String() string            { return proto.CompactTextString(m) }
func (*InferenceResponse) ProtoMessage()               {}
func (*InferenceResponse) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{3} }

func (m *InferenceResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *InferenceResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *InferenceResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *InferenceResponse) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type MonitorMetric struct {
	Kind  string  `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Pid   string  `protobuf:"bytes,2,opt,name=pid,proto3" json:"pid,omitempty"`
	Code  string  `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	Value float64 `protobuf:"fixed64,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MonitorMetric) Reset()                    { *m = MonitorMetric{} }
func (m *MonitorMetric) String() string            { return proto.CompactTextString(m) }
func (*MonitorMetric) ProtoMessage()               {}
func (*MonitorMetric) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{4} }

func (m *MonitorMetric) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *MonitorMetric) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *MonitorMetric) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *MonitorMetric) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type NumpyNdarray struct {
	Dtype string  `protobuf:"bytes,1,opt,name=dtype,proto3" json:"dtype,omitempty"`
	Shape []int32 `protobuf:"varint,2,rep,packed,name=shape" json:"shape,omitempty"`
	Data  []byte  `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *NumpyNdarray) Reset()                    { *m = NumpyNdarray{} }
func (m *NumpyNdarray) String() string            { return proto.CompactTextString(m) }
func (*NumpyNdarray) ProtoMessage()               {}
func (*NumpyNdarray) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{5} }

func (m *NumpyNdarray) GetDtype() string {
	if m != nil {
		return m.Dtype
	}
	return ""
}

func (m *NumpyNdarray) GetShape() []int32 {
	if m != nil {
		return m.Shape
	}
	return nil
}

func (m *NumpyNdarray) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type PingMsg struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *PingMsg) Reset()                    { *m = PingMsg{} }
func (m *PingMsg) String() string            { return proto.CompactTextString(m) }
func (*PingMsg) ProtoMessage()               {}
func (*PingMsg) Descriptor() ([]byte, []int) { return fileDescriptorEval, []int{6} }

func (m *PingMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*ForwardMsg)(nil), "ForwardMsg")
	proto.RegisterType((*ForwardMsgs)(nil), "ForwardMsgs")
	proto.RegisterType((*InferenceRequest)(nil), "InferenceRequest")
	proto.RegisterType((*InferenceRequest_RequestData)(nil), "InferenceRequest.RequestData")
	proto.RegisterType((*InferenceResponse)(nil), "InferenceResponse")
	proto.RegisterType((*MonitorMetric)(nil), "MonitorMetric")
	proto.RegisterType((*NumpyNdarray)(nil), "NumpyNdarray")
	proto.RegisterType((*PingMsg)(nil), "PingMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Forward service

type ForwardClient interface {
	Forward(ctx context.Context, in *ForwardMsgs, opts ...grpc.CallOption) (*ForwardMsgs, error)
}

type forwardClient struct {
	cc *grpc.ClientConn
}

func NewForwardClient(cc *grpc.ClientConn) ForwardClient {
	return &forwardClient{cc}
}

func (c *forwardClient) Forward(ctx context.Context, in *ForwardMsgs, opts ...grpc.CallOption) (*ForwardMsgs, error) {
	out := new(ForwardMsgs)
	err := grpc.Invoke(ctx, "/Forward/Forward", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Forward service

type ForwardServer interface {
	Forward(context.Context, *ForwardMsgs) (*ForwardMsgs, error)
}

func RegisterForwardServer(s *grpc.Server, srv ForwardServer) {
	s.RegisterService(&_Forward_serviceDesc, srv)
}

func _Forward_Forward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForwardMsgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardServer).Forward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Forward/Forward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardServer).Forward(ctx, req.(*ForwardMsgs))
	}
	return interceptor(ctx, in, info, handler)
}

var _Forward_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Forward",
	HandlerType: (*ForwardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Forward",
			Handler:    _Forward_Forward_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eval.proto",
}

// Client API for Inference service

type InferenceClient interface {
	Inference(ctx context.Context, in *InferenceRequest, opts ...grpc.CallOption) (*InferenceResponse, error)
	Ping(ctx context.Context, in *PingMsg, opts ...grpc.CallOption) (*PingMsg, error)
}

type inferenceClient struct {
	cc *grpc.ClientConn
}

func NewInferenceClient(cc *grpc.ClientConn) InferenceClient {
	return &inferenceClient{cc}
}

func (c *inferenceClient) Inference(ctx context.Context, in *InferenceRequest, opts ...grpc.CallOption) (*InferenceResponse, error) {
	out := new(InferenceResponse)
	err := grpc.Invoke(ctx, "/Inference/Inference", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inferenceClient) Ping(ctx context.Context, in *PingMsg, opts ...grpc.CallOption) (*PingMsg, error) {
	out := new(PingMsg)
	err := grpc.Invoke(ctx, "/Inference/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Inference service

type InferenceServer interface {
	Inference(context.Context, *InferenceRequest) (*InferenceResponse, error)
	Ping(context.Context, *PingMsg) (*PingMsg, error)
}

func RegisterInferenceServer(s *grpc.Server, srv InferenceServer) {
	s.RegisterService(&_Inference_serviceDesc, srv)
}

func _Inference_Inference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferenceServer).Inference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inference/Inference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferenceServer).Inference(ctx, req.(*InferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Inference_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InferenceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Inference/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InferenceServer).Ping(ctx, req.(*PingMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Inference_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Inference",
	HandlerType: (*InferenceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Inference",
			Handler:    _Inference_Inference_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Inference_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eval.proto",
}

func (m *ForwardMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.Meta) > 0 {
		for k, _ := range m.Meta {
			dAtA[i] = 0x12
			i++
			v := m.Meta[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovEval(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovEval(uint64(len(k))) + byteSize
			i = encodeVarintEval(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEval(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintEval(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.NetworkInputBuf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.NetworkInputBuf)))
		i += copy(dAtA[i:], m.NetworkInputBuf)
	}
	if len(m.NetworkOutputBuf) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.NetworkOutputBuf)))
		i += copy(dAtA[i:], m.NetworkOutputBuf)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Reqid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Reqid)))
		i += copy(dAtA[i:], m.Reqid)
	}
	return i, nil
}

func (m *ForwardMsgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardMsgs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for _, msg := range m.Msgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEval(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InferenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InferenceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEval(dAtA, i, uint64(m.Data.Size()))
		n1, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Datas) > 0 {
		for _, msg := range m.Datas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEval(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Params)))
		i += copy(dAtA[i:], m.Params)
	}
	if len(m.Reqid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Reqid)))
		i += copy(dAtA[i:], m.Reqid)
	}
	return i, nil
}

func (m *InferenceRequest_RequestData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InferenceRequest_RequestData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.Attribute) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Attribute)))
		i += copy(dAtA[i:], m.Attribute)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *InferenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InferenceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEval(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Result) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *MonitorMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitorMetric) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Pid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Pid)))
		i += copy(dAtA[i:], m.Pid)
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.Value != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Eval(dAtA, i, uint64(math.Float64bits(float64(m.Value))))
	}
	return i, nil
}

func (m *NumpyNdarray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumpyNdarray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dtype) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Dtype)))
		i += copy(dAtA[i:], m.Dtype)
	}
	if len(m.Shape) > 0 {
		dAtA3 := make([]byte, len(m.Shape)*10)
		var j2 int
		for _, num1 := range m.Shape {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintEval(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *PingMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEval(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func encodeFixed64Eval(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Eval(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEval(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ForwardMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	if len(m.Meta) > 0 {
		for k, v := range m.Meta {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovEval(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovEval(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovEval(uint64(mapEntrySize))
		}
	}
	l = len(m.NetworkInputBuf)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.NetworkOutputBuf)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Reqid)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	return n
}

func (m *ForwardMsgs) Size() (n int) {
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovEval(uint64(l))
		}
	}
	return n
}

func (m *InferenceRequest) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovEval(uint64(l))
	}
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovEval(uint64(l))
		}
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Reqid)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	return n
}

func (m *InferenceRequest_RequestData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Attribute)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	return n
}

func (m *InferenceResponse) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovEval(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	return n
}

func (m *MonitorMetric) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Pid)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	if m.Value != 0 {
		n += 9
	}
	return n
}

func (m *NumpyNdarray) Size() (n int) {
	var l int
	_ = l
	l = len(m.Dtype)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	if len(m.Shape) > 0 {
		l = 0
		for _, e := range m.Shape {
			l += sovEval(uint64(e))
		}
		n += 1 + sovEval(uint64(l)) + l
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	return n
}

func (m *PingMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovEval(uint64(l))
	}
	return n
}

func sovEval(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEval(x uint64) (n int) {
	return sovEval(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ForwardMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEval
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEval
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEval
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEval
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthEval
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEval(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEval
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Meta[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInputBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInputBuf = append(m.NetworkInputBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.NetworkInputBuf == nil {
				m.NetworkInputBuf = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkOutputBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkOutputBuf = append(m.NetworkOutputBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.NetworkOutputBuf == nil {
				m.NetworkOutputBuf = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardMsgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardMsgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardMsgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &ForwardMsg{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InferenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InferenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InferenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &InferenceRequest_RequestData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &InferenceRequest_RequestData{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reqid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InferenceRequest_RequestData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attribute = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InferenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InferenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InferenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitorMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitorMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitorMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Value = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumpyNdarray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumpyNdarray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumpyNdarray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dtype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dtype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEval
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Shape = append(m.Shape, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEval
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEval
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEval
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Shape = append(m.Shape, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Shape", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEval
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEval
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEval
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEval(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEval
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEval(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEval
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEval
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEval
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEval
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEval
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEval(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEval = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEval   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("eval.proto", fileDescriptorEval) }

var fileDescriptorEval = []byte{
	// 563 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xdd, 0x8e, 0xd2, 0x40,
	0x14, 0xde, 0x42, 0x01, 0x7b, 0xc0, 0x08, 0x27, 0x6a, 0x1a, 0x5c, 0x91, 0xf4, 0x46, 0x34, 0xa6,
	0x89, 0xac, 0x89, 0xc6, 0xcb, 0x8d, 0x9a, 0xec, 0x05, 0xa8, 0x7d, 0x01, 0x32, 0xd0, 0xa1, 0x4e,
	0xa0, 0x3f, 0x3b, 0x3f, 0xbb, 0xe1, 0x0d, 0x7c, 0x34, 0x2f, 0x7d, 0x04, 0xc3, 0x6b, 0x78, 0x63,
	0x66, 0x3a, 0x2d, 0xd5, 0xbd, 0xf0, 0xaa, 0xdf, 0x37, 0xe7, 0x9b, 0x39, 0xe7, 0x7c, 0xe7, 0x00,
	0x00, 0xbd, 0x21, 0xfb, 0xb0, 0xe0, 0xb9, 0xcc, 0x83, 0xef, 0x2d, 0x80, 0x4f, 0x39, 0xbf, 0x25,
	0x3c, 0x5e, 0x88, 0x04, 0x11, 0x5c, 0xa5, 0x58, 0xec, 0x3b, 0x53, 0x67, 0xe6, 0x45, 0x06, 0xe3,
	0x0b, 0x70, 0x53, 0x2a, 0x89, 0xdf, 0x9a, 0xb6, 0x67, 0xfd, 0xf9, 0xa3, 0xf0, 0x24, 0x0f, 0x17,
	0x54, 0x92, 0x8f, 0x99, 0xe4, 0x87, 0xc8, 0x48, 0xf0, 0x25, 0x8c, 0x32, 0x2a, 0x6f, 0x73, 0xbe,
	0x5b, 0xb1, 0xac, 0x50, 0x72, 0xb5, 0x56, 0x5b, 0xbf, 0x3d, 0x75, 0x66, 0x83, 0xe8, 0x81, 0x0d,
	0x5c, 0xe9, 0xf3, 0x4b, 0xb5, 0xc5, 0x57, 0x80, 0x95, 0x36, 0x57, 0xb2, 0x12, 0xbb, 0x46, 0x3c,
	0xb4, 0x91, 0xcf, 0x26, 0xa0, 0xd5, 0x08, 0x6e, 0x4c, 0xc5, 0xc6, 0xef, 0x94, 0x85, 0x69, 0x8c,
	0x0f, 0xa1, 0xc3, 0xe9, 0x35, 0x8b, 0xfd, 0xae, 0x39, 0x2c, 0xc9, 0xf8, 0x2d, 0x78, 0x75, 0x59,
	0x38, 0x84, 0xf6, 0x8e, 0x1e, 0x6c, 0x3b, 0x1a, 0xea, 0x4b, 0x37, 0x64, 0xaf, 0xa8, 0xdf, 0x32,
	0x99, 0x4a, 0xf2, 0xbe, 0xf5, 0xce, 0x09, 0x42, 0xe8, 0x9f, 0x5a, 0x13, 0xf8, 0x0c, 0xdc, 0x54,
	0x24, 0xc2, 0x77, 0x4c, 0xdb, 0xfd, 0x46, 0xdb, 0x91, 0x09, 0x04, 0xbf, 0x1d, 0x18, 0x5e, 0x65,
	0x5b, 0xca, 0x69, 0xb6, 0xa1, 0x11, 0xbd, 0x56, 0x54, 0x48, 0x7c, 0x0d, 0x6e, 0x4c, 0x24, 0x31,
	0x19, 0xfb, 0xf3, 0xa7, 0xe1, 0xbf, 0x82, 0xd0, 0x7e, 0x3f, 0x10, 0x49, 0x22, 0x23, 0xc5, 0x0b,
	0xe8, 0xe8, 0xaf, 0xb0, 0x06, 0xff, 0xe7, 0x4e, 0xa9, 0xc5, 0xc7, 0xd0, 0x2d, 0x08, 0x27, 0xa9,
	0x30, 0xf6, 0x7a, 0x91, 0x65, 0x27, 0x4f, 0xdc, 0xa6, 0x27, 0x5f, 0xa1, 0xdf, 0x78, 0x43, 0xbb,
	0xa2, 0x38, 0xab, 0x5c, 0x51, 0x9c, 0xe1, 0x39, 0x78, 0x44, 0x4a, 0xce, 0xd6, 0x4a, 0x96, 0xce,
	0x78, 0xd1, 0xe9, 0x40, 0x9b, 0xbf, 0xce, 0xe3, 0x83, 0x9d, 0xa4, 0xc1, 0x41, 0x0a, 0xa3, 0x46,
	0x9d, 0xa2, 0xc8, 0x33, 0x61, 0x84, 0x9b, 0x3c, 0xa6, 0xe6, 0xe5, 0x4e, 0x64, 0x30, 0xfa, 0xd0,
	0x4b, 0xa9, 0x10, 0x24, 0xa9, 0x1e, 0xae, 0xa8, 0xee, 0x81, 0x53, 0xa1, 0xf6, 0xd2, 0x4e, 0xd5,
	0xb2, 0x3a, 0x5d, 0xb7, 0x91, 0x6e, 0x05, 0xf7, 0x17, 0x79, 0xc6, 0x64, 0xce, 0x17, 0x54, 0x72,
	0xb6, 0xd1, 0xa2, 0x1d, 0xcb, 0xea, 0x4d, 0xd5, 0x58, 0xf7, 0x55, 0xb0, 0xd8, 0xa6, 0xd1, 0xb0,
	0x2e, 0xa8, 0x34, 0xa9, 0x2c, 0xa8, 0xde, 0x00, 0x6d, 0x91, 0x63, 0x37, 0x20, 0x58, 0xc2, 0x60,
	0xa9, 0xd2, 0xe2, 0xb0, 0x8c, 0x09, 0xe7, 0xc4, 0xec, 0x49, 0x2c, 0x0f, 0x05, 0xb5, 0x09, 0x4a,
	0xa2, 0x4f, 0xc5, 0x37, 0x52, 0x50, 0x33, 0xab, 0x4e, 0x54, 0x12, 0xb3, 0x9c, 0x7a, 0xe8, 0xd6,
	0x1f, 0x8d, 0x83, 0x27, 0xd0, 0xfb, 0xc2, 0xb2, 0x44, 0xff, 0xa8, 0x86, 0xd0, 0x4e, 0x45, 0x52,
	0xd9, 0x9d, 0x8a, 0x64, 0x3e, 0x87, 0x9e, 0x5d, 0x27, 0x7c, 0x7e, 0x82, 0x83, 0xc6, 0x8e, 0x89,
	0xf1, 0x5f, 0x2c, 0x38, 0x9b, 0xaf, 0xc0, 0xab, 0x0d, 0xc7, 0x37, 0x4d, 0x32, 0xba, 0xb3, 0x31,
	0x63, 0x0c, 0xef, 0x0c, 0x27, 0x38, 0xc3, 0x73, 0x70, 0x75, 0x4d, 0x78, 0x2f, 0xb4, 0xa5, 0x8d,
	0x6b, 0x14, 0x9c, 0x5d, 0x0e, 0x7e, 0x1c, 0x27, 0xce, 0xcf, 0xe3, 0xc4, 0xf9, 0x75, 0x9c, 0x38,
	0xeb, 0xae, 0xf9, 0x7f, 0xb8, 0xf8, 0x13, 0x00, 0x00, 0xff, 0xff, 0x25, 0x44, 0xfb, 0x2b, 0x2d,
	0x04, 0x00, 0x00,
}
